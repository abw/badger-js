<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | @abw/badger</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-badger.css"><meta name="description" content="Component based framework and utility modules"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@abw/badger"><meta property="twitter:description" content="Component based framework and utility modules"></head>
<body class="layout-container manual-root" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/abw/badger-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/getting_started.html"><a href="manual/getting_started.html" data-ice="link">Getting Started</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting_started.html"><a href="manual/getting_started.html#file-utilities" data-ice="link">File Utilities</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting_started.html"><a href="manual/getting_started.html#codecs" data-ice="link">Codecs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting_started.html"><a href="manual/getting_started.html#configuration-files" data-ice="link">Configuration Files</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting_started.html"><a href="manual/getting_started.html#library-modules" data-ice="link">Library Modules</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting_started.html"><a href="manual/getting_started.html#data-paths" data-ice="link">Data Paths</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown" data-ice="content"><h1 id="getting-started">Getting Started</h1><p>The <code>badger</code> toolkit provides a range of classes and utility
functions for server-side Javascript using Node.js.</p>
<p>There is no particular rhyme or reason as to what's included
or excluded from the toolkit.  It contains the kind of things
that I've found to be useful to help build and manage
non-trivial software projects.</p>
<h2 id="file-utilities">File Utilities</h2><p>Let's start with the file utilities.  Say you've got a script
in your project which needs to read a file from a different
directory.</p>
<p>Let's assume that the script is <code>bin/hello.js</code> and you want
to read the contents of the file in <code>data/hello.txt</code>.  The
<code>bin</code> function accepts the URL of the source file which you
can get from <code>import.meta.url</code> and returns an object
representing the directory that it's in.  Note that this will
always be the same directory regardless of where you run the
script from.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { bin } from '@abw/badger'

// current directory where this script is located
const thisDir = bin(import.meta.url);</code></code></pre>
<p>The <code>parent()</code> method returns the parent directory and on that
we can call the <code>directory()</code> (or <code>dir()</code> for short) method to access a
directory beneath that.  In this case, we're going for the <code>data</code>
directory.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">// directory where the data file is located
const dataDir = thisDir.parent().dir('data');</code></code></pre>
<p>We can then access the <code>hello.txt</code> file in that directory and
read the file content using the <code>read()</code> method.  This returns
a Promise which will fulfull with the file content.  Add a
<code>.then()</code> handler to do something with the content.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">dataDir.file('hello.txt').read().then(
  text =&gt; console.log(text)
)</code></code></pre>
<p>We can chain all those function/method calls together like so:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { bin } from '@abw/badger'

bin(import.meta.url)
  .parent()
  .dir('data')
  .file('hello.txt')
  .read()
  .then( text =&gt; console.log(text) )</code></code></pre>
<p>Writing files is just as easy:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { bin } from '@abw/badger'

bin(import.meta.url)
  .parent()
  .dir('data')
  .file('goodbye.txt')
  .write('K thx bye');</code></code></pre>
<p>For further information see the documentation for the
<a href="../class/src/Badger/Filesystem/Directory.js~Directory">Directory</a> and
<a href="../class/src/Badger/Filesystem/File.js~File">File</a> modules.</p>
<h2 id="codecs">Codecs</h2><p>Codecs are used to encode and decode data to and from serialised text.  The badger toolkit comes with two built-in codecs for <code>json</code> and <code>yaml</code> files.</p>
<p>Suppose that we have a <code>badger.yaml</code> file in the <code>data</code> directory that we
want to read.</p>
<pre><code class="lang-yaml"><code class="source-code prettyprint">name:   Brian
animal: Badger</code></code></pre>
<p>All we have to do is add the <code>{ codec: "yaml" }</code>
options to the <code>file()</code> method.  The <code>read()</code> method will then
automatically decode the YAML text.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { bin } from '@abw/badger'

bin(import.meta.url)
  .parent()
  .directory('data')
  .file('badger.yaml', { codec: 'yaml' })
  .read().then(
    data =&gt; console.log(data.name, 'is a', data.animal)
  )</code></code></pre>
<p>This prints the string "Brian is a Badger" to the console.</p>
<p>The <code>codec</code> option also works when writing data.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { bin } from '@abw/badger'

bin(import.meta.url)
  .parent()
  .directory('data')
  .file('giraffe.yaml', { codec: 'yaml' })
  .write({
    name:   "Gerald",
    animal: "Giraffe",
  })</code></code></pre>
<p>You should now have a <code>data/giraffe.yaml</code> file containing the following:</p>
<pre><code class="lang-yaml"><code class="source-code prettyprint">name: Gerald
animal: Giraffe</code></code></pre>
<h2 id="configuration-files">Configuration Files</h2><p>We all know (hopefully) that it's considered harmful to hard-code values in code
that might conceivably change at some point.  Furthermore, the DRY (Don't
Repeat Yourself) principle tells us that <em>"Every piece of knowledge must
have a single, unambiguous, authoritative representation within a system"</em>.</p>
<p>So it's good practice to have a single location where configuration options for your
project can be stored.  For a smaller projects this might be a single configuration
file (e.g. consider how <code>package.json</code> is used for NPM modules). For larger projects
you may choose to have several configuration files to achieve a better separation
of concerns and to make them easier to manage.</p>
<p>The <a href="../class/src/Badger/Config.js~Config">Config</a> module simplifies the process
of reading configuration files stored in a central location.  Tell it where your
configuration files are stored and then it will take care of loading them for you.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { Config } from '@abw/badger'

// look for config files in a `config` directory
const configDir = new Config('config')

// load the badger.(js|mjs|yaml|json) file
configDir.config('badger').then(
  config =&gt; console.log("loading the badger config: ", config)
)</code></code></pre>
<p>When you create a new <code>Config</code> object you should specify the name of the
configuration file relative to your current location.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const configDir = new Config('config')</code></code></pre>
<p>You can specify it as a string as shown above, or using a
<a href="../class/src/Badger/Filesystem/Directory.js~Directory">Directory</a> object as
shown in the earlier examples. For example, if you have a script in the <code>bin</code>
directory and you want to load configuration files from the <code>config</code> directory
located alongside it then you can do something like this:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { bin, Config } from '@abw/badger'

const configDir = new Config(
  bin(import.meta.url).parent().dir('config')
)</code></code></pre>
<p>Or more succinctly like this:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { bin, Config } from '@abw/badger'

const configDir = new Config(
  bin(import.meta.url).dir('../config')
)</code></code></pre>
<p>If you have multiple locations that you want to read configuration files
from then you can specify them as an array.  The values of the array can be
either Directory objects or strings, or a mixture of the two.  For example if
for some reason you have a <code>config</code> directory and a <code>system</code> directory that
you want to read configuration files from then you could do this:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const rootDir = bin(import.meta.url).parent()

const configDir = new Config(
  [rootDir.dir('config'), rootDir.dir('system')]
)</code></code></pre>
<p>The <code>config()</code> method expects the basename (i.e. no file extension) of a file
in your config directory (or one of them).</p>
<pre><code class="lang-js"><code class="source-code prettyprint">// load the badger.(js|mjs|yaml|json) file
configDir.config('badger').then(
  config =&gt; console.log("loaded the badger config: ", config)
)</code></code></pre>
<p>It will first look for a Javascript file with a <code>.js</code> or <code>.mjs</code> extension.
If it finds such a file then it will import it and return a Promise that
fulfills with the exports from that file.  For example, a <code>config/badger.js</code>
file might look like this:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">export const name="Brian";
export const animal="Badger";</code></code></pre>
<p>If it doesn't find a Javascript file then it will look for a <code>yaml</code> or <code>json</code>
file.  For example, a <code>config/badger.yaml</code> might look like this:</p>
<pre><code class="lang-yaml"><code class="source-code prettyprint">name:   Brian
animal: Badger</code></code></pre>
<p>Or a <code>config/badger.json</code> might look like this:</p>
<pre><code class="lang-json"><code class="source-code prettyprint">{
  "name":   "Brian",
  "animal": "Badger"
}</code></code></pre>
<p>In all the above cases, the same data will be returned in the Promise.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">configDir.config('badger').then(
  // prints "Brian is a Badger"
  config =&gt; console.log(config.name, "is a", config.animal)
)</code></code></pre>
<p>The <code>jsExt</code> configuration option can be used to change the file extensions
that are recognised for Javascript files (<code>['js', 'mjs']</code> by default) and
the <code>codecs</code> option can be used to specify which codecs can be used for
data files (<code>['yaml', 'json']</code> by default).  Note that the names of the
<code>codecs</code> correspond to the file extensions, e.g. a file must have a <code>.yaml</code>
extension to be reconised and read using the <code>yaml</code> codec.</p>
<p>For example, if you only want to look for <code>.js</code> Javascript files and <code>.json</code>
data files then you would set the options like this:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const configDir = new Config(
  rootDir.dir('config'),
  {
    jsExt:  ['js'],
    codecs: ['json'],
  };
)</code></code></pre>
<p>Or, given that you now only have one value for each of <code>jsExt</code> and <code>codecs</code> you
could do it like this:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const configDir = new Config(
  rootDir.dir('config'),
  {
    jsExt:  'js',
    codecs: 'json',
  };
)</code></code></pre>
<p>In case it's not immediately obvious, one key benefit of using the Config module to
load configuration files is that it allows you to change the format that you're
using at any time.  You might start off with a simple <code>.json</code> JSON file then later decide
that you want to change to a <code>.yaml</code> YAML file so that you can add some comments and whitespace
to make it more readable.  Further down the line you might need to perform some
computation and switch it to a <code>.js</code> Javascript file.</p>
<p>Of course you still need to re-write your configuration file but you don't need to worry about
updating any code that's loading it.  When you add a <code>badger.yaml</code> file to the configuration
directory it will immediately take precedence over the <code>badger.json</code> file, or if you add a
<code>badger.js</code> file it will take precedence over both the <code>badger.yaml</code> and <code>badger.json</code> files.</p>
<p>This is why you should <strong>NOT</strong> provide the file extension in the name you pass to the
<code>config()</code> method.  Leave it up to the <code>config()</code> method to work that out for you
and do the right thing.</p>
<h2 id="library-modules">Library Modules</h2><p>The <a href="../class/src/Badger/Library.js~Library">Library</a> module is similar to the
<a href="../class/src/Badger/Config.js~Config">Config</a> module except that it's designed to
work only with Javascript files.</p>
<p>Create a library directory specifying one or more directories where your code is located.
Then call the <code>library()</code> method to load a <code>.js</code> or <code>.mjs</code> module from any of those
directories.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { Library } from '@abw/badger'

const libraryDir = new Library(
  ['src', 'lib']
)

// load first of src/Example.js, src/Example.mjs, lib/Example.js or lib/Example.mjs
libraryDir.library('Example').then(
  exports =&gt; {
    // do something with your code exports here
  }
)</code></code></pre>
<p>The Promise returned fulfills to an object containing all the exports from your library
module.</p>
<h2 id="data-paths">Data Paths</h2><p>Both the <a href="../class/src/Badger/Config.js~Config">Config</a> and
<a href="../class/src/Badger/Library.js~Library">Library</a> modules provide a
convenient way to drill down into the data returned to fetch a particular item.</p>
<p>For example, suppose you have the following configuration file in <code>config/zoo.yaml</code>.</p>
<pre><code class="lang-yaml"><code class="source-code prettyprint">animals:
  aardvark:
    name: Alan
  badger:
    name: Brian
  cat:
    name: Colin</code></code></pre>
<p>If you have a Config object setup to read files from the <code>config</code> directory then
you can read the whole of the <code>zoo</code> data set like this:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">configDir.config('zoo').then(
  zoo =&gt; console.log("The badger is called ", zoo.animals.badger.name) // The badger is called Brian
)</code></code></pre>
<p>If you're only looking for a particular item, in this case the name of the badger,
then you can add a data path fragment to the file name, like this:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">configDir.config('zoo#animals/badger/name').then(
  name =&gt; console.log("The badger is called ", name) // The badger is called Brian
)</code></code></pre>
<p>Each element of the data path should be separated by a slash.  You can specify
text elements to access items in an object (as shown above) or numerical elements to
access items in an array.</p>
<p>For example, if you have some data that looks like this:</p>
<pre><code class="lang-json"><code class="source-code prettyprint">{
  "numbers": ["zero", "one", "two", "forty-two"],
  "friends": [
    { "name": "Ford Prefect" },
    { "name": "Zaphod Beeblebrox" },
    { "name": "Trillian" },
  ]
}</code></code></pre>
<p>Then a data path of <code>numbers/3</code> would return "forty-two", or <code>friends/0/name</code> would return
"Ford Prefect".</p>
<p>If an item is <code>undefined</code> or <code>null</code> then an error is thrown.  Using the above data this would
happen if you tried to access <code>friends/12/name</code> or <code>friends/0/birthday</code></p>
<p>You can add an question mark to the end of a path segment to make it silently return <code>undefined</code>
instead, e.g. <code>friends/12?/name</code> or <code>friends/0/birthday?</code>.  Note that the question mark can only
appear at the end of a segment.  If it appears anywhere else then it is assumed to be the same
thing as <code>?/</code>.  e.g. <code>foo?bar</code> is the same as <code>foo?/bar</code>.</p>
<p>You can enclose any segment in single or double quotes if you happen to have data keys that include
<code>/</code> or <code>?</code> characters in them.  For example, <code>question/"What is the answer?"</code> to access the value
"42" in the following data:</p>
<pre><code class="lang-json"><code class="source-code prettyprint">{
  "question": {
    "What is the answer?": 42
  }
}</code></code></pre>
<p>If you want to make a quoted part optional then add the question mark after the closing quote, e.g.
<code>question/"What is the question?"</code> would throw an error because it is not defined, but can be specified
as <code>question/"What is the question?"?</code> to instead return <code>undefined</code>.</p>
<p>The data path syntax is intentionally simple and limited.  If you want to do anything more complicated
then you should consider using JSON Path instead.</p>
<p>All of the above applies to the data returned by the Config and Library modules when loaded
Javascript files.  By default they will return an object containing all exported values from the
Javascript file.  If you want to access the <code>default</code> export, for example, then you can add a <code>#default</code> suffix
to the file basename when loading it.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">libraryDir.library('Example#default').then(
  default =&gt; {
    // do something with the default export here
  }
)</code></code></pre>
<p>Any other named export can be accessed in the same way.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">libraryDir.library('Example#anotherExport').then(
  anotherExport =&gt; {
    // do something with anotherExport here
  }
)</code></code></pre>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>


</body></html>